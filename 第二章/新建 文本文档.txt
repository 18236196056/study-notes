1：局部变量在方法体内声明的包括方法的参数（main（方法的参数）），成员变量是在方法体以外类体里面声明的。
2：方法的作用域，凡是在大括号里声明的出了大括号就不认识了
3：4类8中基本类型
   逻辑性-boolean
   文本型-char
   整数型-byte，short，int，long
   浮点型=fioat，double
（可以用内存里占小格的布局或内存里的大小来存分内存的类型）

boolean

  类型数据只允许取值true或fales，不可以用0或非0的整数代替true和false

char
java字符采用Unicode（统一了所有国家文字的一种编码方式）编码，每个字符占两个字节，因而可用十六进制编码形式表示。每一个0/1叫做一位（一个bit），一个字节（bit）八位（最多占8位，可以表示2^8个字符）。（中国的字符用gbk/gb2312，台湾的叫大五码）；Unicode分为两种一种Utf8，一种Utf16（java用的）；（十进制转换为二进制（例如15=8+4+2+1,1110）），十六进制A是10，B是11……（‘\u0061’0061代表在内存里是0000000001100001，\n代表换行符，\u代表后四位数是十六进制的Unicode的编码）

整数类型
byte（1字节-2^7--2^7-1），short（2字节-2^15--2^15-1），int（4字节），long（8字节）
java 中语言整形常量的三种表示形式十进制，八进制（要求0开头），十六进制（0x开头）。
java语言的整数类型常量默认为int型，声明long型常量可以后加l或者L（long i1=8888888L；必须加L否则会出错）

浮点类型
java浮点型常量默认为double型，如果要声明一个常量为float型，则需要在数字后面加f或者F；float占4字节（精度小数点后7位），double占8字节（小数点以后15位）所以浮点数是有误差的。
5：基础数据类型的转换

（1）boolean类型不可以转换为其他的数据类型
（2）整形，字符型，浮点型的数据在混合运算中互相转换
    容量小的类型自动转换为容量大的数据类型，数据类型按照容量大小排序
    byte，short，char之间不会互相转换，他们在运算时自动转换为int型
    容量大的变小的时候要加上强制转换符
6:break是直接退出循环了，而countinue是退出本次循环（例如int stop=4；for（int i=1；i<=10；i++）{//当i等于stop时，退出循环。if（i==stop）break；System.out.println（“i=”+i）；}）输出1234；（int skip=4；for（int i=1；i<=5；i++）{//当i等于stop时，跳出循环。if（i==skip）continue；System.out.println（“i=”+i）；}）输出1235；）.break打破的是距离它最近的一个循环
7：switch语句switch（i）{case xx：……  case xx：……  default：…}（i可以为int，char，就是能转换为int的）
8：递归
